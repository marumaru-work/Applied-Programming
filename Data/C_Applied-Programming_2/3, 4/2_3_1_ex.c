#include <stdio.h>

double series(double i, double s, double th)
{
    double p = 1 / ((i - 1) * 2 + 1);
    if (p < th)
    {
        double r = p * s;
        printf("i: %d, judg: %.10f, r: %.10f, s: %d\n", (int) i - 1, p, r, (int) s);
        return r;
    }
    else
    {
        double r = p * s + series((i + 1), -s, th);
        printf("i: %d, judg: %.10f, r: %.10f, s: %d\n", (int) i - 1, p, r, (int) s);
        return r;
    }
}

int main(void)
{
    double th = 0.0001;  // 閾値
    double s = 1.0;      // 符号
    double p = series(1.0, s, th);
    printf("Result: %f\n", p);

    return 0;
}

/*
【定義】
この問題の数式は「ライプニッツの公式」というものらしいです。
「ライプニッツの公式」 → Wikipedia: https://onl.tw/fd2Wsrq

【コメント】
ライプニッツの公式はいたって簡単な数式だが、これを再帰関数に処理をコーディングするのが難点だった。
しかも、 series(1.0, s, th) の 1.0 って何を表している値なのかを記載されていない。予想ではあるが、おそらく変数 i なのだろう、、、。
なお、スマートなソースコードは、 2_3_1.c を参照してください。 2_3_1_ex.c は、内部処理の確認用ソースコードです。

詳しい処理を見たい場合は、このソースコードを実行してみると良いだろう。（今回の課題の場合、i = 5000 (5000行表示) が最後である。）
[ i: i 番目, judg: i 番目にある分数の値 (閾値の判定), r: n 番目 ～ (n - i) 番目 までの計算, s: i 番目の分数の値が {1 なら正(+), -1 なら負(-)} ]

因みに、算出された値に 4 倍すると円周率(3.14...)に近似した値が求まる。

【実行結果】
i: 5000, judg: 0.0000999900, r: 0.0000999900, s: 1
i: 4999...4998...4997.....
--------------------------------------------------
i: 10, judg: 0.0476190476, r: 0.0249882487, s: 1
i: 9, judg: 0.0526315789, r: -0.0276433303, s: -1
i: 8, judg: 0.0588235294, r: 0.0311801991, s: 1
i: 7, judg: 0.0666666667, r: -0.0354864675, s: -1
i: 6, judg: 0.0769230769, r: 0.0414366094, s: 1
i: 5, judg: 0.0909090909, r: -0.0494724815, s: -1
i: 4, judg: 0.1111111111, r: 0.0616386296, s: 1
i: 3, judg: 0.1428571429, r: -0.0812185133, s: -1
i: 2, judg: 0.2000000000, r: 0.1187814867, s: 1
i: 1, judg: 0.3333333333, r: -0.2145518466, s: -1
i: 0, judg: 1.0000000000, r: 0.7854481534, s: 1
Result: 0.785448
*/
